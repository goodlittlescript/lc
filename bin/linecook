#!/usr/bin/env ruby
$:.unshift File.expand_path('../../lib', File.realpath(__FILE__))

begin
  require 'linecook'
  require 'optparse'

  options = Linecook.options(
    :mode  => :render,
    :input => :fields,
    :template_type => :file,
  )
  OptionParser.new do |opts|
    opts.banner = %{
usage: linecook [options] TEMPLATE FIELDS...

  Render ERB templates.

options:

}.lstrip

    opts.on("-A", "--attribute KEY=VALUE", "set an attribute") do |input|
      key, value = input.split("=")
      options[:attributes][key] = value
    end

    opts.on("-a", "--attributes-file FILE", "set attributes from file") do |input|
      attrs = YAML.load_file(input)
      options[:attributes].merge!(attrs)
    end

    opts.on("-c", "--csv-files", "treat fields as csv files") do
      options[:input] = :csv_files
    end

    opts.on("-e", "set template from string") do
      options[:template_type] = :string
    end

    opts.on("-F", "--field-sep FS", "csv field sep (assumes -c)") do |input|
      options[:input] = :csv_files
      options[:field_sep] = input
    end

    opts.on("-f", "--force", "overwrite existing on -o") do
      options[:force] = true
    end

    opts.on("-H", "--headers", "map csv headers to fields (assumes -c)") do
      options[:input] = :csv_files
      options[:headers] = true
    end

    opts.on("-h", "--help", "print this help") do
      puts opts
      puts
      exit
    end

    opts.on("-I", "--path LINECOOK_PATH", "set template search path") do |input|
      options[:path] = input
    end

    opts.on("-l", "--list", "list templates") do
      options[:mode] = :list
    end

    opts.on("-o", "--output-dir DIR", "output result to dir") do |input|
      options[:output_dir] = input
    end

    opts.on("-X", "--example", "print example template") do
      options[:mode] = :example
    end

    opts.on("-x", "--explain", "print properties section") do
      options[:mode] = :explain
    end

  end.parse!

  mode  = options[:mode]
  input = options[:input]
  template_type = options[:template_type]

  config = Linecook.setup(options)
  template_file, *fields = ARGV; ARGV.clear

  if mode == :list
    config.templates.each_pair do |name, template|
      if template_file.nil? || name.index(template_file) == 0
        puts name unless template_file == name
      end
    end
    exit 0
  end

  if mode == :example
    puts "\
#!/usr/bin/env linecook
##############################################################################
# Properties - YAML front matter
# * attrs are shared per-render (ex: global attributes file)
# * fields are specific to a render (ex: lines in a CSV file)
#
# Template
# * methods are made to access attrs/fields by name
# * methods return defaults unless overridden
##############################################################################
attrs:
  key: value
fields:
  a: x
  b: y
  c: z
---
attrs: <%= attrs.inspect %>
fields: <%= fields.inspect %>
key: <%= key %>
a: <%= a %>
b: <%= b %>
c: <%= c %>
file: <%= __template_file__ %>
name: <%= __template_name__ %>
"
    exit 0
  end

  if template_file.nil?
    $stderr.puts "no template specified"
    exit 1
  end

  if template_type == :string
    require 'tempfile'
    tempfile = Tempfile.new("linecook")
    tempfile.puts(template_file)
    tempfile.close
    template_file = tempfile.path
  end

  template = \
  if File.exists?(template_file)
    Linecook::Template.new(template_file, config.attributes)
  else
    config.templates[template_file]
  end

  if template.nil?
    $stderr.puts "could not find template: #{template_file.inspect}"
    exit 1
  end

  if mode == :explain
    puts YAML.dump(template.properties)
    exit 0
  end

  config.output(template) do |io|
    case input
    when :fields
      io.print template.result(fields)
    when :csv_files
      csv_files = fields

      if csv_files.empty?
        csv_files << "-" 
      end

      csv_files.each do |file|
        file = 0 if file == "-"
        File.open(file) do |source|
          parser = config.parser(source, template.field_names)
          while fields = parser.gets
            io.print template.result(fields)
          end
        end
      end
    end
  end

rescue Interrupt
  exit 130
rescue Errno::EPIPE
  exit 0
end
